{
  "id": "thinking-recovery.ts-api-f17b7b99",
  "file_path": "/Users/user/opencode-autognosis/reference repos/opencode-antigravity-auth/src/plugin/thinking-recovery.ts",
  "chunk_type": "api",
  "content": "# API Surface: thinking-recovery.ts\n\n## Public Functions\n\n### analyzeConversationState\n```typescript\nexport function analyzeConversationState(contents: any[]): ConversationState\n```\nAnalyzes conversation state to detect tool use loops and thinking mode issues.\n\nKey insight: A \"turn\" can span multiple assistant messages in a tool-use loop.\nWe need to find the TURN START (first assistant message after last real user message)\nand check if THAT message had thinking, not just the last assistant message.\n\n**Parameters:**\n- `contents`: any[] - \n\n**Returns:** ConversationState\n\n\n### closeToolLoopForThinking\n```typescript\nexport function closeToolLoopForThinking(contents: any[]): any[]\n```\nCloses an incomplete tool loop by injecting synthetic messages to start a new turn.\n\nThis is the \"let it crash and start again\" recovery mechanism.\n\nWhen we detect:\n- We're in a tool loop (conversation ends with functionResponse)\n- The tool call was made WITHOUT thinking (thinking was stripped/corrupted)\n- We NOW want to enable thinking\n\nInstead of trying to fix the corrupted state, we:\n1. Strip ALL thinking blocks (removes any corrupted ones)\n2. Add synthetic MODEL message to complete the non-thinking turn\n3. Add synthetic USER message to start a NEW turn\n\nThis allows Claude to generate fresh thinking for the new turn.\n\n**Parameters:**\n- `contents`: any[] - \n\n**Returns:** any[]\n\n\n### needsThinkingRecovery\n```typescript\nexport function needsThinkingRecovery(state: ConversationState): boolean\n```\nChecks if conversation state requires tool loop closure for thinking recovery.\n\nReturns true if:\n- We're in a tool loop (state.inToolLoop)\n- The turn didn't start with thinking (state.turnHasThinking === false)\n\nThis is the trigger for the \"let it crash and start again\" recovery.\n\n**Parameters:**\n- `state`: ConversationState - \n\n**Returns:** boolean\n\n\n### looksLikeCompactedThinkingTurn\n```typescript\nexport function looksLikeCompactedThinkingTurn(msg: any): boolean\n```\nDetects if a message looks like it was compacted from a thinking-enabled turn.\n\nThis is a heuristic to distinguish between:\n- \"Never had thinking\" (model didn't use thinking mode)\n- \"Thinking was stripped\" (context compaction removed thinking blocks)\n\nPort of LLM-API-Key-Proxy's _looks_like_compacted_thinking_turn()\n\nHeuristics:\n1. Has functionCall parts (typical thinking flow produces tool calls)\n2. No thinking parts (thought: true)\n3. No text content before functionCall (thinking responses usually have text)\n\n**Parameters:**\n- `msg`: any - \n\n**Returns:** boolean\n\n\n### hasPossibleCompactedThinking\n```typescript\nexport function hasPossibleCompactedThinking(\n  contents: any[],\n  turnStartIdx: number,\n): boolean\n```\nChecks if any message in the current turn looks like it was compacted.\n\n**Parameters:**\n- `contents`: any[] - \n- `turnStartIdx`: number - \n\n**Returns:** boolean\n\n\n## Classes\n\n\n## Interfaces\n\n### ConversationState\n```typescript\nexport interface ConversationState\n```\nThinking Recovery Module\n\nMinimal implementation for recovering from corrupted thinking state.\nWhen Claude's conversation history gets corrupted (thinking blocks stripped/malformed),\nthis module provides a \"last resort\" recovery by closing the current turn and starting fresh.\n\nPhilosophy: \"Let it crash and start again\" - Instead of trying to fix corrupted state,\nwe abandon the corrupted turn and let Claude generate fresh thinking.\n\n\n## Types\n",
  "metadata": {
    "created_at": "2026-01-30T05:26:52.067Z",
    "updated_at": "2026-01-30T05:26:52.067Z",
    "hash": "ffad64c9dbe32175beb122c12a1ef98d704a01814e571d84a70c1644c6416cfd",
    "dependencies": [],
    "symbols": [
      "ConversationState",
      "isThinkingPart",
      "isFunctionResponsePart",
      "isFunctionCallPart",
      "isToolResultMessage",
      "parts",
      "messageHasThinking",
      "messageHasToolCalls",
      "analyzeConversationState",
      "state",
      "lastRealUserIdx",
      "i",
      "msg",
      "i",
      "msg",
      "role",
      "hasThinking",
      "hasToolCalls",
      "lastMsg",
      "stripAllThinkingBlocks",
      "filteredParts",
      "filteredContent",
      "countTrailingToolResults",
      "count",
      "i",
      "msg",
      "parts",
      "functionResponses",
      "closeToolLoopForThinking",
      "strippedContents",
      "toolResultCount",
      "syntheticModelContent",
      "syntheticModel",
      "syntheticUser",
      "needsThinkingRecovery",
      "looksLikeCompactedThinkingTurn",
      "parts",
      "hasFunctionCall",
      "hasThinking",
      "hasTextBeforeFunctionCall",
      "firstFuncIdx",
      "hasPossibleCompactedThinking",
      "i",
      "msg"
    ],
    "complexity_score": 100
  }
}