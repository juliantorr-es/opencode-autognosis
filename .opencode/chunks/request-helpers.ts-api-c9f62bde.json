{
  "id": "request-helpers.ts-api-c9f62bde",
  "file_path": "/Users/user/opencode-autognosis/reference repos/opencode-antigravity-auth/src/plugin/request-helpers.ts",
  "chunk_type": "api",
  "content": "# API Surface: request-helpers.ts\n\n## Public Functions\n\n### cleanJSONSchemaForAntigravity\n```typescript\nexport function cleanJSONSchemaForAntigravity(schema: any): any\n```\nCleans a JSON schema for Antigravity API compatibility.\nTransforms unsupported features into description hints while preserving semantic information.\n\nPorted from CLIProxyAPI's CleanJSONSchemaForAntigravity (gemini_schema.go)\n\n**Parameters:**\n- `schema`: any - \n\n**Returns:** any\n\n\n### isThinkingCapableModel\n```typescript\nexport function isThinkingCapableModel(modelName: string): boolean\n```\nChecks if a model name indicates thinking/reasoning capability.\nModels with \"thinking\", \"gemini-3\", or \"opus\" in their name support extended thinking.\n\n**Parameters:**\n- `modelName`: string - \n\n**Returns:** boolean\n\n\n### extractThinkingConfig\n```typescript\nexport function extractThinkingConfig(\n  requestPayload: Record<string, unknown>,\n  rawGenerationConfig: Record<string, unknown> | undefined,\n  extraBody: Record<string, unknown> | undefined,\n): ThinkingConfig | undefined\n```\nExtracts thinking configuration from various possible request locations.\nSupports both Gemini-style thinkingConfig and Anthropic-style thinking options.\n\n**Parameters:**\n- `requestPayload`: Record<string, unknown> - \n- `rawGenerationConfig`: Record<string, unknown> | undefined - \n- `extraBody`: Record<string, unknown> | undefined - \n\n**Returns:** ThinkingConfig | undefined\n\n\n### extractVariantThinkingConfig\n```typescript\nexport function extractVariantThinkingConfig(\n  providerOptions: Record<string, unknown> | undefined\n): VariantThinkingConfig | undefined\n```\nExtracts variant thinking config from OpenCode's providerOptions.\n\nAll Antigravity models route through the Google provider, so we only check\nproviderOptions.google. Supports two formats:\n\n1. Gemini 3 native: { google: { thinkingLevel: \"high\", includeThoughts: true } }\n2. Budget-based (Claude/Gemini 2.5): { google: { thinkingConfig: { thinkingBudget: 32000 } } }\n\n**Parameters:**\n- `providerOptions`: Record<string, unknown> | undefined - \n\n**Returns:** VariantThinkingConfig | undefined\n\n\n### resolveThinkingConfig\n```typescript\nexport function resolveThinkingConfig(\n  userConfig: ThinkingConfig | undefined,\n  isThinkingModel: boolean,\n  _isClaudeModel: boolean,\n  _hasAssistantHistory: boolean,\n): ThinkingConfig | undefined\n```\nDetermines the final thinking configuration based on model capabilities and user settings.\nFor Claude thinking models, we keep thinking enabled even in multi-turn conversations.\nThe filterUnsignedThinkingBlocks function will handle signature validation/restoration.\n\n**Parameters:**\n- `userConfig`: ThinkingConfig | undefined - \n- `isThinkingModel`: boolean - \n- `_isClaudeModel`: boolean - \n- `_hasAssistantHistory`: boolean - \n\n**Returns:** ThinkingConfig | undefined\n\n\n### filterUnsignedThinkingBlocks\n```typescript\nexport function filterUnsignedThinkingBlocks(\n  contents: any[],\n  sessionId?: string,\n  getCachedSignatureFn?: (sessionId: string, text: string) => string | undefined,\n  isClaudeModel?: boolean,\n): any[]\n```\nFilters thinking blocks from contents unless the signature matches our cache.\nAttempts to restore signatures from cache for thinking blocks that lack signatures.\n\n**Parameters:**\n- `contents`: any[] - \n- `sessionId`: string - \n- `getCachedSignatureFn`: (sessionId: string, text: string) => string | undefined - \n- `isClaudeModel`: boolean - \n\n**Returns:** any[]\n\n\n### filterMessagesThinkingBlocks\n```typescript\nexport function filterMessagesThinkingBlocks(\n  messages: any[],\n  sessionId?: string,\n  getCachedSignatureFn?: (sessionId: string, text: string) => string | undefined,\n  isClaudeModel?: boolean,\n): any[]\n```\nFilters thinking blocks from Anthropic-style messages[] payloads using cached signatures.\n\n**Parameters:**\n- `messages`: any[] - \n- `sessionId`: string - \n- `getCachedSignatureFn`: (sessionId: string, text: string) => string | undefined - \n- `isClaudeModel`: boolean - \n\n**Returns:** any[]\n\n\n### deepFilterThinkingBlocks\n```typescript\nexport function deepFilterThinkingBlocks(\n  payload: unknown,\n  sessionId?: string,\n  getCachedSignatureFn?: (sessionId: string, text: string) => string | undefined,\n  isClaudeModel?: boolean,\n): unknown\n```\nNo documentation found\n\n**Parameters:**\n- `payload`: unknown - \n- `sessionId`: string - \n- `getCachedSignatureFn`: (sessionId: string, text: string) => string | undefined - \n- `isClaudeModel`: boolean - \n\n**Returns:** unknown\n\n\n### transformThinkingParts\n```typescript\nexport function transformThinkingParts(response: unknown): unknown\n```\nTransforms thinking/reasoning content in response parts to OpenCode's expected format.\nHandles both Gemini-style (thought: true) and Anthropic-style (type: \"thinking\") formats.\nAlso extracts reasoning_content for Anthropic-style responses.\n\n**Parameters:**\n- `response`: unknown - \n\n**Returns:** unknown\n\n\n### normalizeThinkingConfig\n```typescript\nexport function normalizeThinkingConfig(config: unknown): ThinkingConfig | undefined\n```\nEnsures thinkingConfig is valid: includeThoughts only allowed when budget > 0.\n\n**Parameters:**\n- `config`: unknown - \n\n**Returns:** ThinkingConfig | undefined\n\n\n### parseAntigravityApiBody\n```typescript\nexport function parseAntigravityApiBody(rawText: string): AntigravityApiBody | null\n```\nParses an Antigravity API body; handles array-wrapped responses the API sometimes returns.\n\n**Parameters:**\n- `rawText`: string - \n\n**Returns:** AntigravityApiBody | null\n\n\n### extractUsageMetadata\n```typescript\nexport function extractUsageMetadata(body: AntigravityApiBody): AntigravityUsageMetadata | null\n```\nExtracts usageMetadata from a response object, guarding types.\n\n**Parameters:**\n- `body`: AntigravityApiBody - \n\n**Returns:** AntigravityUsageMetadata | null\n\n\n### extractUsageFromSsePayload\n```typescript\nexport function extractUsageFromSsePayload(payload: string): AntigravityUsageMetadata | null\n```\nWalks SSE lines to find a usage-bearing response chunk.\n\n**Parameters:**\n- `payload`: string - \n\n**Returns:** AntigravityUsageMetadata | null\n\n\n### rewriteAntigravityPreviewAccessError\n```typescript\nexport function rewriteAntigravityPreviewAccessError(\n  body: AntigravityApiBody,\n  status: number,\n  requestedModel?: string,\n): AntigravityApiBody | null\n```\nEnhances 404 errors for Antigravity models with a direct preview-access message.\n\n**Parameters:**\n- `body`: AntigravityApiBody - \n- `status`: number - \n- `requestedModel`: string - \n\n**Returns:** AntigravityApiBody | null\n\n\n### isEmptyResponseBody\n```typescript\nexport function isEmptyResponseBody(text: string): boolean\n```\nChecks if a JSON response body represents an empty response.\n\nEmpty responses occur when:\n- No candidates in Gemini format\n- No choices in OpenAI format\n- Candidates/choices exist but have no content\n\n**Parameters:**\n- `text`: string - \n\n**Returns:** boolean\n\n\n### createStreamingChunkCounter\n```typescript\nexport function createStreamingChunkCounter(): StreamingChunkCounter\n```\nNo documentation found\n\n**Returns:** StreamingChunkCounter\n\n\n### isMeaningfulSseLine\n```typescript\nexport function isMeaningfulSseLine(line: string): boolean\n```\nChecks if an SSE line contains meaningful content.\n\n**Parameters:**\n- `line`: string - \n\n**Returns:** boolean\n\n\n### recursivelyParseJsonStrings\n```typescript\nexport function recursivelyParseJsonStrings(\n  obj: unknown,\n  skipParseKeys: Set<string> = SKIP_PARSE_KEYS,\n  currentKey?: string,\n): unknown\n```\nNo documentation found\n\n**Parameters:**\n- `obj`: unknown - \n- `skipParseKeys`: Set<string> - \n- `currentKey`: string - \n\n**Returns:** unknown\n\n\n### fixToolResponseGrouping\n```typescript\nexport function fixToolResponseGrouping(contents: any[]): any[]\n```\nGroups function calls with their responses, handling ID mismatches.\n\nThis is a port of LLM-API-Key-Proxy's _fix_tool_response_grouping() function.\n\nWhen context compaction or other processes strip tool responses, the tool call\nIDs become orphaned. This function attempts to recover by:\n\n1. Pass 1: Match by exact ID (normal case)\n2. Pass 2: Match by function name (for ID mismatches)\n3. Pass 3: Match \"unknown_function\" orphans or take first available\n4. Fallback: Create placeholder responses for missing tool results\n\n**Parameters:**\n- `contents`: any[] - \n\n**Returns:** any[]\n\n\n### detectToolIdMismatches\n```typescript\nexport function detectToolIdMismatches(contents: any[]):\n```\nChecks if contents have any tool call/response ID mismatches.\n\n**Parameters:**\n- `contents`: any[] - \n\n**Returns:** {\n  hasMismatches: boolean;\n  expectedIds: string[];\n  foundIds: string[];\n  missingIds: string[];\n  orphanIds: string[];\n}\n\n\n### findOrphanedToolUseIds\n```typescript\nexport function findOrphanedToolUseIds(messages: any[]): Set<string>\n```\nFind orphaned tool_use IDs (tool_use without matching tool_result).\nWorks on Claude format messages.\n\n**Parameters:**\n- `messages`: any[] - \n\n**Returns:** Set<string>\n\n\n### fixClaudeToolPairing\n```typescript\nexport function fixClaudeToolPairing(messages: any[]): any[]\n```\nFix orphaned tool_use blocks in Claude format messages.\nMirrors fixToolResponseGrouping() but for Claude's messages[] format.\n\nClaude format:\n- assistant message with content[]: { type: 'tool_use', id, name, input }\n- user message with content[]: { type: 'tool_result', tool_use_id, content }\n\n**Parameters:**\n- `messages`: any[] - \n\n**Returns:** any[]\n\n\n### validateAndFixClaudeToolPairing\n```typescript\nexport function validateAndFixClaudeToolPairing(messages: any[]): any[]\n```\nValidate and fix tool pairing with fallback nuclear option.\nDefense in depth: tries gentle fix first, then nuclear removal.\n\n**Parameters:**\n- `messages`: any[] - \n\n**Returns:** any[]\n\n\n### injectParameterSignatures\n```typescript\nexport function injectParameterSignatures(\n  tools: any[],\n  promptTemplate = \"\\n\\n⚠️ STRICT PARAMETERS:\n```\nInjects parameter signatures into tool descriptions.\nPort of LLM-API-Key-Proxy's _inject_signature_into_descriptions()\n\nThis helps prevent tool hallucination by explicitly listing parameters\nin the description, making it harder for the model to hallucinate\nparameters from its training data.\n\n**Parameters:**\n- `tools`: any[] - \n- `promptTemplate`: any - \n\n**Returns:** any[]\n\n\n### injectToolHardeningInstruction\n```typescript\nexport function injectToolHardeningInstruction(\n  payload: Record<string, unknown>,\n  instructionText: string,\n): void\n```\nInjects a tool hardening system instruction into the request payload.\nPort of LLM-API-Key-Proxy's _inject_tool_hardening_instruction()\n\n**Parameters:**\n- `payload`: Record<string, unknown> - \n- `instructionText`: string - \n\n**Returns:** void\n\n\n### assignToolIdsToContents\n```typescript\nexport function assignToolIdsToContents(\n  contents: any[]\n):\n```\nAssigns IDs to functionCall parts and returns the pending call IDs by name.\nThis is the first pass of tool ID assignment.\n\n**Parameters:**\n- `contents`: any[] - \n\n**Returns:** { contents: any[]; pendingCallIdsByName: Map<string, string[]>; toolCallCounter: number }\n\n\n### matchResponseIdsToContents\n```typescript\nexport function matchResponseIdsToContents(\n  contents: any[],\n  pendingCallIdsByName: Map<string, string[]>\n): any[]\n```\nMatches functionResponse IDs to their corresponding functionCall IDs.\nThis is the second pass of tool ID assignment.\n\n**Parameters:**\n- `contents`: any[] - \n- `pendingCallIdsByName`: Map<string, string[]> - \n\n**Returns:** any[]\n\n\n### applyToolPairingFixes\n```typescript\nexport function applyToolPairingFixes(\n  payload: Record<string, unknown>,\n  isClaude: boolean\n):\n```\nApplies all tool fixes to a request payload for Claude models.\nThis includes:\n1. Tool ID assignment for functionCalls\n2. Response ID matching for functionResponses\n3. Orphan recovery via fixToolResponseGrouping\n4. Claude format pairing fix via validateAndFixClaudeToolPairing\n\n**Parameters:**\n- `payload`: Record<string, unknown> - \n- `isClaude`: boolean - \n\n**Returns:** { contentsFixed: boolean; messagesFixed: boolean }\n\n\n### createSyntheticErrorResponse\n```typescript\nexport function createSyntheticErrorResponse(\n  errorMessage: string,\n  requestedModel: string = \"unknown\",\n): Response\n```\nCreates a synthetic Claude SSE streaming response with error content.\n\nWhen returning HTTP 400/500 errors to OpenCode, the session becomes locked\nand the user cannot use /compact or other commands. This function creates\na fake \"successful\" SSE response (200 OK) with the error message as text content,\nallowing the user to continue using the session.\n\n**Parameters:**\n- `errorMessage`: string - \n- `requestedModel`: string - \n\n**Returns:** Response\n\n\n## Classes\n\n\n## Interfaces\n\n### AntigravityApiError\n```typescript\nexport interface AntigravityApiError\n```\nNo documentation found\n\n\n### AntigravityApiBody\n```typescript\nexport interface AntigravityApiBody\n```\nMinimal representation of Antigravity API responses we touch.\n\n\n### AntigravityUsageMetadata\n```typescript\nexport interface AntigravityUsageMetadata\n```\nUsage metadata exposed by Antigravity responses. Fields are optional to reflect partial payloads.\n\n\n### ThinkingConfig\n```typescript\nexport interface ThinkingConfig\n```\nNormalized thinking configuration accepted by Antigravity.\n\n\n### VariantThinkingConfig\n```typescript\nexport interface VariantThinkingConfig\n```\nVariant thinking config extracted from OpenCode's providerOptions.\n\n\n### StreamingChunkCounter\n```typescript\nexport interface StreamingChunkCounter\n```\nChecks if a streaming SSE response yielded zero meaningful chunks.\n\nThis is used after consuming a streaming response to determine if retry is needed.\n\n\n## Types\n",
  "metadata": {
    "created_at": "2026-01-30T05:26:52.014Z",
    "updated_at": "2026-01-30T05:26:52.014Z",
    "hash": "ecfb98234e1851d7225310e70455ec74b06ec6872aa30a13423726593e0498ae",
    "dependencies": [
      "./config",
      "./logger",
      "../constants",
      "./image-saver",
      "./transform/types"
    ],
    "symbols": [
      "log",
      "ANTIGRAVITY_PREVIEW_LINK",
      "UNSUPPORTED_CONSTRAINTS",
      "UNSUPPORTED_KEYWORDS",
      "appendDescriptionHint",
      "existing",
      "newDescription",
      "convertRefsToHints",
      "refVal",
      "defName",
      "hint",
      "existingDesc",
      "newDescription",
      "result",
      "convertConstToEnum",
      "result",
      "addEnumHints",
      "result",
      "vals",
      "addAdditionalPropertiesHints",
      "result",
      "moveConstraintsToDescription",
      "result",
      "constraint",
      "mergeAllOf",
      "result",
      "merged",
      "mergedRequired",
      "item",
      "req",
      "existingRequired",
      "scoreSchemaOption",
      "type",
      "tryMergeEnumFromUnion",
      "enumValues",
      "option",
      "val",
      "flattenAnyOfOneOf",
      "result",
      "unionKey",
      "options",
      "parentDesc",
      "mergedEnum",
      "bestIdx",
      "bestScore",
      "allTypes",
      "i",
      "selected",
      "childDesc",
      "uniqueTypes",
      "hint",
      "flattenTypeArrays",
      "result",
      "localNullableFields",
      "types",
      "hasNull",
      "nonNullTypes",
      "firstType",
      "newProps",
      "propPath",
      "processed",
      "objectPath",
      "existing",
      "nullableAtRoot",
      "removeUnsupportedKeywords",
      "result",
      "propertiesResult",
      "cleanupRequiredFields",
      "result",
      "validRequired",
      "addEmptySchemaPlaceholder",
      "result",
      "isObjectType",
      "hasProperties",
      "cleanJSONSchemaForAntigravity",
      "result",
      "AntigravityApiError",
      "AntigravityApiBody",
      "AntigravityUsageMetadata",
      "ThinkingConfig",
      "DEFAULT_THINKING_BUDGET",
      "isThinkingCapableModel",
      "lowerModel",
      "extractThinkingConfig",
      "thinkingConfig",
      "config",
      "anthropicThinking",
      "thinking",
      "VariantThinkingConfig",
      "extractVariantThinkingConfig",
      "google",
      "result",
      "tc",
      "search",
      "resolveThinkingConfig",
      "isThinkingPart",
      "hasSignatureField",
      "isToolBlock",
      "stripAllThinkingBlocks",
      "removeTrailingThinkingBlocks",
      "result",
      "part",
      "isValid",
      "hasValidSignature",
      "signature",
      "getSignature",
      "signature",
      "isOurCachedSignature",
      "text",
      "partSignature",
      "cachedSignature",
      "getThinkingText",
      "maybeText",
      "maybeText",
      "stripCacheControlRecursively",
      "result",
      "sanitizeThinkingPart",
      "textContent",
      "maybeText",
      "hasContent",
      "sanitized",
      "thinkingContent",
      "maybeText",
      "hasContent",
      "sanitized",
      "textContent",
      "maybeText",
      "hasContent",
      "sanitized",
      "findLastAssistantIndex",
      "i",
      "content",
      "filterContentArray",
      "filtered",
      "item",
      "isThinking",
      "hasSignature",
      "existingSignature",
      "hasValidSignature",
      "thinkingText",
      "sentinelPart",
      "sanitized",
      "text",
      "cachedSignature",
      "restoredPart",
      "sanitized",
      "filterUnsignedThinkingBlocks",
      "lastAssistantIdx",
      "isLastAssistant",
      "filteredParts",
      "trimmedParts",
      "isAssistantRole",
      "isLastAssistantContent",
      "filteredContent",
      "trimmedContent",
      "filterMessagesThinkingBlocks",
      "lastAssistantIdx",
      "isAssistantRole",
      "isLastAssistant",
      "filteredContent",
      "trimmedContent",
      "deepFilterThinkingBlocks",
      "visited",
      "walk",
      "obj",
      "transformGeminiCandidate",
      "content",
      "thinkingTexts",
      "transformedParts",
      "transformed",
      "thinkingText",
      "transformed",
      "parsedArgs",
      "result",
      "transformThinkingParts",
      "resp",
      "result",
      "reasoningTexts",
      "transformedContent",
      "block",
      "thinkingText",
      "normalizeThinkingConfig",
      "record",
      "budgetRaw",
      "includeRaw",
      "thinkingBudget",
      "includeThoughts",
      "enableThinking",
      "finalInclude",
      "normalized",
      "parseAntigravityApiBody",
      "parsed",
      "firstObject",
      "extractUsageMetadata",
      "usage",
      "asRecord",
      "toNumber",
      "extractUsageFromSsePayload",
      "lines",
      "line",
      "jsonText",
      "parsed",
      "usage",
      "rewriteAntigravityPreviewAccessError",
      "error",
      "trimmedMessage",
      "messagePrefix",
      "enhancedMessage",
      "needsPreviewAccessOverride",
      "errorMessage",
      "isAntigravityModel",
      "isEmptyResponseBody",
      "parsed",
      "firstCandidate",
      "content",
      "parts",
      "hasContent",
      "firstChoice",
      "message",
      "response",
      "StreamingChunkCounter",
      "createStreamingChunkCounter",
      "count",
      "hasRealContent",
      "isMeaningfulSseLine",
      "data",
      "parsed",
      "candidate",
      "parts",
      "part",
      "SKIP_PARSE_KEYS",
      "recursivelyParseJsonStrings",
      "result",
      "stripped",
      "hasControlCharEscapes",
      "hasIntentionalEscapes",
      "parsed",
      "lastBracket",
      "cleaned",
      "parsed",
      "lastBrace",
      "cleaned",
      "parsed",
      "fixToolResponseGrouping",
      "newContents",
      "pendingGroups",
      "collectedResponses",
      "content",
      "role",
      "parts",
      "responseParts",
      "resp",
      "respId",
      "i",
      "group",
      "groupResponses",
      "resp",
      "funcCalls",
      "callIds",
      "funcNames",
      "group",
      "groupResponses",
      "i",
      "expectedId",
      "expectedName",
      "matchedId",
      "orphanName",
      "orphanResp",
      "placeholder",
      "detectToolIdMismatches",
      "expectedIds",
      "foundIds",
      "content",
      "parts",
      "part",
      "expectedSet",
      "foundSet",
      "missingIds",
      "orphanIds",
      "findOrphanedToolUseIds",
      "toolUseIds",
      "toolResultIds",
      "msg",
      "block",
      "fixClaudeToolPairing",
      "toolUseMap",
      "i",
      "msg",
      "block",
      "toolResultIds",
      "msg",
      "block",
      "orphans",
      "orphansByMsgIndex",
      "orphan",
      "existing",
      "result",
      "i",
      "orphansForMsg",
      "nextMsg",
      "placeholders",
      "removeOrphanedToolUse",
      "validateAndFixClaudeToolPairing",
      "fixed",
      "orphanIds",
      "formatTypeHint",
      "type",
      "enumVals",
      "items",
      "itemType",
      "nestedProps",
      "nestedReq",
      "nestedList",
      "t",
      "req",
      "nestedProps",
      "nestedReq",
      "nestedList",
      "t",
      "req",
      "injectParameterSignatures",
      "declarations",
      "newDeclarations",
      "schema",
      "required",
      "properties",
      "paramList",
      "typeHint",
      "isRequired",
      "sigStr",
      "injectToolHardeningInstruction",
      "existing",
      "parts",
      "instructionPart",
      "parts",
      "assignToolIdsToContents",
      "toolCallCounter",
      "pendingCallIdsByName",
      "newContents",
      "newParts",
      "call",
      "nameKey",
      "queue",
      "matchResponseIdsToContents",
      "newParts",
      "resp",
      "queue",
      "applyToolPairingFixes",
      "contentsFixed",
      "messagesFixed",
      "contentsWithMatchedIds",
      "createSyntheticErrorResponse",
      "messageId",
      "events",
      "body"
    ],
    "complexity_score": 100
  }
}